from __future__ import annotations
import os
from dataclasses import dataclass
from typing import Tuple, Dict, Optional, List
import math
import random
import warnings
import numpy as np
import matplotlib.pyplot as plt

def run_verification():
    """
    Verification script to run an OpenSees structural analysis using the 
    geometric data generated by the CSF (Continuous Section Field) library.
    
    The script simulates a cantilever beam under a vertical tip load to 
    validate that the varying cross-sectional properties are correctly 
    interpreted by the Finite Element solver.
    """

    # 1. PATH CONFIGURATION
    # The 'geometry.tcl' file acts as the bridge between the CSF geometric 
    # engine and the OpenSees structural solver. It contains the raw data 
    # for each integration point along the beam's length.
    file_path = "geometry.tcl"
    
    if not os.path.exists(file_path):
        print(f"ERROR: Geometry file not found at {file_path}. Please generate it first.")
        return

    # 2. DATA EXTRACTION (Matrix Building)
    # OpenSees usually reads TCL files directly, but here we parse it 
    # manually to store properties in a Python list. This allows us to 
    # inspect the data and dynamically build the FE model.
    section_matrix = []
    with open(file_path, 'r') as f:
        for line in f:
            # We look for lines defining 'section Elastic' properties
            if line.strip().startswith("section Elastic"):
                parts = line.split()
                # OpenSees Elastic Section Syntax: 
                # tag, E (Modulus), A (Area), Iz (Strong Axis), Iy (Weak Axis), G (Shear Modulus), J (Torsion)
                section_matrix.append({
                    'tag': int(parts[2]),
                    'E':   float(parts[3]),
                    'A':   float(parts[4]),
                    'Iz':  float(parts[5]),
                    'Iy':  float(parts[6]),
                    'G':   float(parts[7]),
                    'J':   float(parts[8])
                })

    # PRINT FULL DATA MATRIX FOR USER VERIFICATION
    # This table allows the user to visually confirm the tapering or 
    # variation of the section before the analysis starts.
    print("\n" + "="*95)
    print(f"{'TAG':<4} | {'Area (A)':<10} | {'Iz (Strong)':<12} | {'Iy (Weak)':<12} | {'E (Modulus)':<10} | {'J (Tors)':<10}")
    print("-" * 95)
    for s in section_matrix:
        print(f"{s['tag']:<4} | {s['A']:<10.6f} | {s['Iz']:<12.6e} | {s['Iy']:<12.6e} | {s['E']:<10.2e} | {s['J']:<10.2e}")
    print("="*95)

    # 3. OPENSEES MODEL INITIALIZATION
    # wipe: Clears any existing OpenSees model from memory to start fresh.
    try:
        import openseespy.opensees as ops
        ops.wipe()
    except Exception as e:
        print("I'm sorry your system doesn't seem able to use openseespy")
        print(e)
        exit(1)
    # model: Defines the model space. 
    # '-ndm' 3: Three-dimensional space.
    # '-ndf' 6: Six degrees of freedom per node (3 translations, 3 rotations).
    ops.model('basic', '-ndm', 3, '-ndf', 6)

    # In this specific verification setup, we discretize the 10m beam 
    # into a number of elements equal to the number of sections found in the file.
    total_length = 10.0
    num_elements = len(section_matrix)
    element_length = total_length / num_elements

    # NODE CREATION
    # Nodes are the physical points in space where elements are connected.
    # We place them along the Z-axis, creating 'num_elements' segments.
    for i in range(num_elements + 1):
        # node(ID, X, Y, Z)
        ops.node(i+1, 0.0, 0.0, float(i * element_length))

    # COORDINATE TRANSFORMATION
    # In 3D, we must tell OpenSees how the local beam axes are oriented 
    # relative to the global axes. 'Linear' is used for small displacements.
    # '1.0, 0.0, 0.0' defines the vector for the local Y-axis orientation.
    ops.geomTransf('Linear', 1, 1.0, 0.0, 0.0)

    # 4. SECTION AND ELEMENT ASSIGNMENT
    # This loop maps the geometric properties from our matrix to the FE elements.
    for i, data in enumerate(section_matrix):
        s_tag = data['tag']
        
        # ops.section: Creates a mathematical definition of the cross-section 
        # based on the elastic properties (Area, Inertia, etc.) at this point.
        ops.section('Elastic', s_tag, data['E'], data['A'], data['Iz'], data['Iy'], data['G'], data['J'])
        
        # ops.beamIntegration: Defines how the solver integrates forces along 
        # the element. Using 'Legendre' with 2 points provides a standard 
        # numerical integration for that specific segment.
        ops.beamIntegration('Legendre', s_tag, s_tag, 2)
        
        # ops.element: Creates the physical 3D beam member.
        # 'forceBeamColumn' is used because it is highly accurate for elements 
        # where the internal forces follow a linear distribution (like cantilevers).
        # Connecting Node (i+1) to Node (i+2) using transformation tag 1.
        ops.element('forceBeamColumn', i+1, i+1, i+2, 1, s_tag)

    # 5. BOUNDARY CONDITIONS AND LOADING
    # ops.fix: Defines the supports. 
    # Node 1 is fixed (1 means constrained, 0 means free) in all 6 directions.
    # This creates a perfect 'encastrÃ©' or cantilever support.
    ops.fix(1, 1, 1, 1, 1, 1, 1) 
    
    # APPLYING THE LOAD
    # timeSeries: Defines how the load changes over time (Linear = constant rate).
    ops.timeSeries('Linear', 1)
    # pattern: A container for loads.
    ops.pattern('Plain', 1, 1)
    # load: Applies force to the last node (the tip of the cantilever).
    # load(NodeID, Fx, Fy, Fz, Mx, My, Mz)
    # We apply -50,000 Newtons (50kN) downwards on the Y-axis.
    ops.load(num_elements + 1, 0.0, -50000.0, 0.0, 0.0, 0.0, 0.0)

    # 6. ANALYSIS EXECUTION SETTINGS
    # These commands configure the mathematical solver (algorithms and systems).
    ops.constraints('Plain')      # Handling of boundary conditions
    ops.numberer('RCM')           # Optimization of node numbering for speed
    ops.system('BandGeneral')     # Type of matrix solver to use
    ops.algorithm('Linear')       # Use a linear solution algorithm (standard for elastic)
    ops.integrator('LoadControl', 1.0) # Step size for the load application
    ops.analysis('Static')        # Perform a static (not time-dependent) analysis

    # PERFORM THE ANALYSIS
    # 'analyze(1)' attempts to solve the system for 1 load step.
    if ops.analyze(1) == 0:
        # If successful, extract the vertical displacement (Degree of Freedom 2) at the tip.
        displacement = ops.nodeDisp(num_elements + 1, 2)
        print(f"\nOPENSEES ANALYSIS RESULTS:")
        # Convert displacement from meters to millimeters for readability.
        print(f" > Tip Vertical Displacement: {abs(displacement*1000):.4f} mm")
        print("="*95 + "\n")
    else:
        print("\n[ERROR] Analysis failed to converge. Check geometry or boundary conditions.")

if __name__ == "__main__":
    run_verification()