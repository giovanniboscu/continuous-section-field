# Geometric Model

## Overview

The geometric model adopted in CSF is intentionally explicit and minimal.  
All sectional properties are derived from **user-defined geometry**, without predefined templates or implicit assumptions.

CSF represents the geometry of a non-prismatic member as a **ruled solid** generated by interpolating polygonal cross-sections along a longitudinal axis `z`.

This chapter defines the geometric assumptions, constraints, and rules that govern this representation.

---

## Reference System

CSF adopts a **local Cartesian reference system**:

- The `z` axis coincides with the member longitudinal axis.
- Cross-sections are defined in planes orthogonal to `z`.
- Each section is described in a local `x-y` plane.

In the base CSF formulation, two reference sections are used:
- start section at `z = z0`,
- end section at `z = z1` (typically `z1 = L`).

All section geometries must be expressed in the **same `x-y` orientation**.  
Relative rotation between reference sections is not supported in the current formulation.

---

## Section Definition

A section is defined as a **collection of closed polygonal regions**.

Each polygon represents a material subdomain or a void subdomain of the cross-section.

### Polygon Rules

For a polygon to be valid in CSF, it must satisfy all the following conditions:

1. **Closed polyline**  
   The polygon is closed by CSF. Repeating the first vertex is optional.

2. **Counter-clockwise orientation (CCW)**  
   Vertices must be ordered CCW. This is a strict requirement for consistent Green/shoelace sign conventions in area and inertia computation. See "One-polygon encoding (@cell)" for mandatory bridge rules and validity constraints of inner-loop single-polygon encoding.


3. **No self-intersection**  
   Polygons must be simple and non-self-intersecting.

4. **Planar geometry**  
   All vertices lie in the same `x-y` plane.

Violation of these rules produces invalid geometry and must be corrected upstream (parser/validator stage).

---

## Multi-Polygon Sections

A single section may contain multiple polygons, enabling representation of:

- hollow sections,
- multi-cell layouts,
- composite arrangements,
- embedded components.

Each polygon is treated as an independent geometric region with its own attributes.

Containment relationships (one polygon inside another) are interpreted as **geometric nesting**, not as additive material overlap.

---

## Polygon Identity and Correspondence

For interpolation along `z`, polygons defined at different reference sections must be **topologically consistent**.

This means:

- the same number of polygons must exist at each reference section,
- each corresponding polygon must keep the same vertex count,
- **Polygon pairing is resolved by list index between `S0` and `S1`: polygon `i` in `S0` pairs with polygon `i` in `S1` (creation order), not by geometric proximity.**

- **For every index `i`, `S0.polygons[i]` must correspond to `S1.polygons[i]`; this index-based rule is the only pairing criterion.**


Polygon names are used for tracking and assignment of physical laws, but they do not define geometric pairing.

This design keeps interpolation deterministic and reproducible.

---

## Ruled-Surface Interpolation

The 3D member geometry is generated through ruled-surface interpolation.

For each corresponding vertex `Pi`, the position at coordinate `z` is:

`Pi(z) = Pi0 + ((z - z0) / (z1 - z0)) * (Pi1 - Pi0)`

where:

- `Pi0` is the vertex at the start section,
- `Pi1` is the corresponding vertex at the end section.

This produces:

- linear interpolation of vertex coordinates,
- planar surface patches between corresponding edges,
- continuous geometric evolution without intermediate geometric fitting.

---

## Geometric Continuity

The ruled-surface formulation guarantees:

- `C0` geometric continuity,
- deterministic and reproducible intermediate sections,
- no spline-induced oscillations or smoothing artifacts.

Curved outlines are approximated by increasing polygon vertex density.  
No higher-order geometric interpolation is applied.

---

## Intermediate Sections

An intermediate section at any `z` in `[z0, z1]` is obtained by:

1. evaluating interpolated coordinates of all vertices,
2. reconstructing each polygon at that station,
3. assembling the section with unchanged topology.

This operation is purely geometric and independent of stiffness/material calculations.

---

## Topological Constraints

The following constraints apply along `z`:

- polygon topology must remain unchanged,
- polygon vertex count must remain constant between reference sections,
- polygon order must remain consistent,
- holes/voids must be explicitly represented as polygons.

Topological events (merge/split of regions along `z`) are outside the current scope.

---

## Geometric Accuracy and User Responsibility

CSF does not auto-correct geometry.

- No automatic orientation fixing.
- No automatic vertex reordering.
- No tolerance-based geometric cleanup.

Geometric correctness is a user responsibility and is enforced upstream by validation rules.

This policy avoids hidden corrections and preserves modeling transparency.

---

## Nesting Semantics and Voids

CSF does not implement a separate hole object.  
A hole is represented only as a polygonal region in the section model.

Geometry is polygon-based; numerical contribution is evaluated per subdomain using polygon weight and nesting relations.

### Non-overlap rule in nested regions

For nested polygons, CSF does not sum materials twice on the same footprint.  
The inner polygon defines a distinct subdomain inside the container.

Normative consequence:

- container polygon with `w = 1`,
- inner polygon with `w = 1`,

does **not** create doubled contribution in the overlap area.

A void is modeled explicitly as an inner polygon with `w = 0`.

### Local effective contribution (composite nesting)

For a inner polygon nested in a container polygon, the local effective field is:

`w_eff(z) = w_inner(z) - w_container(z)`

where `inner` is the directly nested inner polygon and `container` is its immediate parent.

### Relation to `@wall` / `@cell`

The rules above (`w = 0` void modeling, nested-domain occupancy, and `w_eff(z) = w_child(z) - w_container(z)`) apply to the composite/nesting path.

By contrast, `@wall` and `@cell` are solver-path tags appended to polygon names.  
They select dedicated torsion workflows and polygon subsets; they do not redefine nesting semantics.

As specified below, `@cell` denotes a single closed cell for torsion evaluation, geometrically represented as one domain with one internal void (one hole).

---

## Equivalent Geometry Encodings The resulting total area must be positive

Consider a rectangular ring:

- outer rectangle: `(0,0) -> (10,0) -> (10,6) -> (0,6)`
- inner void: `(3,2) -> (7,2) -> (7,4) -> (3,4)`

Net area:

`A_net = A_outer - A_hole = 60 - 8 = 52`

### A) Two-polygon encoding

![two_pol_ekofisk_sections](https://github.com/user-attachments/assets/fdcf8848-d8c4-48e1-8b1d-c60c076c5633)

```yaml
# CSF geometry definition with two reference sections (S0 -> S1).
# IMPORTANT: Polygon pairing is index-based, not name/proximity-based.
# Pairing rule:
#   S0.polygons[0] <-> S1.polygons[0]
#   S0.polygons[1] <-> S1.polygons[1]
# This ordering must remain consistent across all sections.

CSF:
  sections:
    S0:
      # ---------------------------
      # Reference section at z = 0
      # ---------------------------
      z: 0.000000
      polygons:
        outer:
          weight: 1.000000 # Full contribution (container domain)
          # Polygon index 0 in S0
          # Paired with polygon index 0 in S1          
          vertices: # CCW point order required
             - [0.0, 0.0]
             - [10.0, 0.0]
             - [10.0, 6.0]
             - [0.0, 6.0]
        # Polygon index 1 in S0
        # Paired with polygon index 1 in S1           
        inner:
          weight: 0.000000 # void
          vertices:
            - [3.0, 2.0]
            - [7.0, 2.0]
            - [7.0, 4.0]
            - [3.0, 4.0]
            
    S1:
      z: 10.000000
      # ---------------------------
      # Reference section at z = 10
      # ---------------------------      
      polygons:
        outer:
          weight: 1.000000  # Full contribution (container domain)
          # Polygon index 0 in S1
          # Must correspond to S0 polygon index 0 (outer)
          vertices:
             - [0.0, 0.0]
             - [10.0, 0.0]
             - [10.0, 6.0]
             - [0.0, 6.0]
        inner:
          weight: 0.000000 # void
          # Polygon index 1 in S1
          # Must correspond to S0 polygon index 1 (inner)
          vertices:
            - [3.0, 2.0]
            - [7.0, 2.0]
            - [7.0, 4.0]
            - [3.0, 4.0]
```




---
This is generally the easiest form to review, validate, and debug.

### B) One-polygon encoding
One-polygon Hole Representation (`@cell`) in CSF

This note explains an alternative way to represent a section with a hole in CSF:  
using **one composite polygon path** instead of two separate polygons (`outer` + `inner_void`).

---

## Why this representation exists

In standard CSF nesting, a hole is typically modeled as a dedicated inner polygon with `weight: 0.0`.

The single-path representation is an **alternative encoding** of the same geometry.  
Its practical value is that the whole ring-like domain can be classified as a single tagged polygon, for example with `@cell`, to drive specific torsion workflows.

---

## Concept

A single polygon entry contains two loops in one ordered point path:

- an **outer loop** (usually CCW),
- an **inner loop** (usually CW),

both explicitly closed.

This encodes a net domain equivalent to: outer boundary minus inner boundary.

---

## Important scope clarification

This encoding is mainly useful when you want to treat the ring as one tagged entity, e.g. `@cell`.

Example name:

- `rect_ring_single_path@cell@t=0.5`

Interpretation:

- base geometric identity: `rect_ring_single_path`
- tags: `@cell`, `@t=0.5`

Tags guide calculation paths (e.g., torsion route selection) and parameters; they do not change the geometric base identity.

---

## Equivalence with two-polygon void model

For the single-path encoding:

- outer loop (CCW): `(0,0) -> (10,0) -> (10,6) -> (0,6) -> (0,0)`
- bridge to inner: `(0,0) -> (3,2)`
- inner loop (CW): `(3,2) -> (3,4) -> (7,4) -> (7,2) -> (3,2)`
- bridge back: `(3,2) -> (0,0)` (required by this encoding rule)


the net area is:

`A_net = A_outer - A_hole = 60 - 8 = 52`

The same physical section can be encoded either as:

1. **two polygons** (`outer_rect`, `inner_void` with `weight: 0.0`), or
2. **one composite path** (outer + inner loops in one polygon entry).

So this is not a different section, but a different representation of the same section.
---

## Minimal YAML pattern (single-path)

``![one_pol_ekofisk_sections](https://github.com/user-attachments/assets/ba6f7f50-76da-480d-8f4d-ca55ba412d28)

```yaml
CSF:
  sections:
    S0:
      z: 0.000000
      polygons:
        outer:
          weight: 1.000000
          vertices:
             # OUTER loop (CCW)
             - [0.0, 0.0]
             - [10.0, 0.0]
             - [10.0, 6.0]
             - [0.0, 6.0]
             - [0.0, 0.0]
             # bridge to inner start
             - [3.0, 2.0]
             # INNER loop (CW)
             - [3.0, 4.0]
             - [7.0, 4.0]
             - [7.0, 2.0]
             - [3.0, 2.0]

    S1:
      z: 10.000000
      polygons:
        outer:
          weight: 1.000000
          vertices:
            # OUTER loop (CCW)
            - [0.0, 0.0]
            - [10.0, 0.0]
            - [10.0, 6.0]
            - [0.0, 6.0]
            - [0.0, 0.0]
            # bridge to inner start
            - [3.0, 2.0]
            # INNER loop (CW)
            - [3.0, 4.0]
            - [7.0, 4.0]
            - [7.0, 2.0]
            - [3.0, 2.0]
```

---

## Practical recommendation

- Use the **two-polygon encoding** when clarity and reviewability are the priority.
- Use the **single-path encoding** when you need one tagged geometric entity (especially for `@cell`-based torsion workflows) and parser support is confirmed.


---

## Summary

The CSF geometric model is based on explicit, verifiable rules:

- polygonal cross-sections,
- strict polygon validity constraints (CCW, simple polygons, planar input),
- fixed topology and ordering across stations,
- ruled-surface interpolation along `z`,
- explicit polygon-based void modeling through nesting and weights.

This framework prioritizes determinism, transparency, and reproducibility as a stable basis for continuous sectional analysis.
