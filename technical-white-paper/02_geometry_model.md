# Geometric Model

## Overview

The geometric model adopted in CSF is intentionally explicit and minimal.  
All sectional properties are derived from **user-defined geometry**, without predefined templates or implicit assumptions.

CSF represents the geometry of a non-prismatic member as a **ruled solid** generated by interpolating polygonal cross-sections along a longitudinal axis ` z `.

This chapter defines the geometric assumptions, constraints, and rules that govern this representation.

---

## Reference System

CSF adopts a **local Cartesian reference system**:

- The **\( z \)-axis** coincides with the member longitudinal axis.
- Cross-sections are defined in planes **normal to` z`**.
- Each section is described in a local **` x-y `** plane.

Two (or more) reference sections are placed at prescribed coordinates:
- start section at` z = z_0 `,
- end section at `z = z_1` (typically ` z_1 = L `).

All section geometries must be expressed in the **same `  x–y` orientation**.  
Relative rotation between sections is not supported in the current formulation.

---

## Section Definition

A section is defined as a **collection of closed polygonal regions**.

Each polygon represents a **material or void subdomain** of the cross-section.

### Polygon Rules

For a polygon to be valid in CSF, it must satisfy the following conditions:

1. **Closed polyline**  
   The polygon is always closed by CSF; repeating the first vertex is optional.

2. **Counter-clockwise orientation (CCW)**  
   Vertices must be ordered counter-clockwise.  
   This is a strict requirement to ensure correct sign conventions when applying Green’s theorem for area and inertia computation.

3. **No self-intersection**  
   Polygons must be simple and non-self-intersecting.

4. **Planar geometry**  
   All vertices lie in the same ` x–y ` plane.

Violation of these rules results in invalid geometry and must be corrected upstream.

---

## Multi-Polygon Sections

A single section may contain **multiple polygons**, allowing the representation of:

- hollow sections,
- multi-cell geometries,
- composite layouts,
- embedded components.

Each polygon is treated as an independent geometric region with its own attributes.

Containment relationships (one polygon inside another) are interpreted as **geometric nesting**, not as overlapping material.

---

## Polygon Identity and Correspondence

For interpolation along ` z `, polygons defined at different reference sections must be **topologically consistent**.

This means:
- the same number of polygons must exist at each reference section,
- polygons are matched **by creation order**, not by geometric proximity.

Polygon names are used for **tracking and assignment of physical laws**, but **do not define geometric pairing**.  
Geometric correspondence is purely positional in the polygon list.

This design choice avoids ambiguity and ensures deterministic interpolation.

---

## Ruled-Surface Interpolation

The 3D geometry of the member is generated through **ruled surfaces**.

For each polygon vertex ` P_i`, the spatial position along the member is defined as:

$$
P_i(z) = P_{i,0} + \frac{z - z_0}{z_1 - z_0} \left( P_{i,1} - P_{i,0} \right)
$$

where:
- ` P_{i,0}` is the vertex at the start section,
- ` P_{i,1} ` is the corresponding vertex at the end section.

This produces:
- linear interpolation of vertex coordinates,
- planar quadrilateral surface patches between corresponding edges,
- a geometrically continuous volume without intermediate discretization.

---

## Geometric Continuity

The ruled-surface formulation guarantees:

- **` C^0`** continuity of the geometry,
- deterministic and reproducible intermediate sections,
- absence of geometric oscillations or smoothing artifacts.

Curvature of outlines is approximated by increasing the number of polygon vertices.  
No spline or higher-order geometric interpolation is performed.

---

## Intermediate Sections

An intermediate section at any coordinate ` z in [z_0, z_1]` is obtained by:

1. evaluating the interpolated position of all vertices,
2. reconstructing each polygon at that location,
3. assembling the section as a set of polygons identical in topology to the reference sections.

This operation is purely geometric and independent of material or stiffness considerations.

---

## Topological Constraints

The following constraints apply to all CSF geometries:

- Polygon topology must remain unchanged along ` z `.
- Polygon vertex count must be constant between reference sections.
- Creation order must be consistent.
- Holes and voids must be explicitly modeled as polygons.

Topology changes along the member (e.g. merging or splitting regions) are outside the current scope.

---

## Geometric Accuracy and User Responsibility

CSF does not attempt to “fix” or regularize geometry.

- No automatic orientation correction is applied.
- No vertex reordering is performed.
- No tolerance-based cleanup is introduced.

Geometric correctness is a **user responsibility**.  
This strict policy avoids hidden corrections and preserves modeling transparency.

---


## Nesting Semantics, Voids, and Equivalent Encodings

CSF does **not** use an explicit "hole entity".  
Geometry is always described by polygons, and numerical contribution is controlled by polygon weight and nesting context.

### Non-overlap semantics in nested regions

When one polygon lies inside another, CSF does not perform a material superposition in the overlapped region as an additive stack.  
The inner polygon occupies its own geometric domain inside the container.

Practical consequence:

- outer square with `w=1`,
- inner square with `w=1`,

does not create a doubled material contribution on the same footprint.  
The model is resolved by domain occupancy, not by blind additive overlap.

This is why a void in CSF is naturally represented as a normal polygon with `w=0`, not as a special object type.

### Reinforced section example (concrete + bars)

A rectangular concrete section with four steel bars near the edges can be represented with five polygons:

- 1 concrete polygon (`w=1`),
- 4 bar polygons (their own material/weight laws).

No mandatory "hole entity" is required.  
An explicit "void + bar" convention is still possible, but the void remains a standard polygon with `w=0`.

### Signed-area conventions

For standard inputs, each single polygon should be oriented to yield positive signed area (CCW point order).  
This preserves consistency of Green/shoelace-based integrals.

An advanced but still trivial case is a **single composite path** that physically represents multiple regions.  
This is relevant in practice and can support compact `@cell` modeling patterns.

Conceptually:

- outer boundary gives positive contribution,
- inner boundary gives negative contribution,
- algebraic sum remains physically consistent for the net domain.

---

### Same figure encoded in two ways

Consider the same ring-like rectangle (outer rectangle minus inner rectangle).

Outer rectangle:
- `(0,0) -> (10,0) -> (10,6) -> (0,6)`

Inner void rectangle:
- `(3,2) -> (7,2) -> (7,4) -> (3,4)`

Net area:

`
A_net = A_outer - A_hole = 60 - 8 = 52
`

Both encodings describe the same geometry.

#### A) Two-polygon encoding

```yaml
CSF_GEOMETRY:
  sections:
    - name: S0
      z: 0.0
      polygons:
        - name: outer_rect
          weight: 1.0
          points:
            - [0.0, 0.0]
            - [10.0, 0.0]
            - [10.0, 6.0]
            - [0.0, 6.0]

        - name: inner_void
          weight: 0.0
          points:
            - [3.0, 2.0]
            - [7.0, 2.0]
            - [7.0, 4.0]
            - [3.0, 4.0]
      z: 10.0
      polygons:
        - name: outer_rect
          weight: 1.0
          points:
            - [0.0, 0.0]
            - [10.0, 0.0]
            - [10.0, 6.0]
            - [0.0, 6.0]

        - name: inner_void
          weight: 0.0
          points:
            - [3.0, 2.0]
            - [7.0, 2.0]
            - [7.0, 4.0]
            - [3.0, 4.0]
```

#### B) Single-polygon composite-path encoding

One polyline encodes outer and inner loops using bridge segments and opposite contribution sense for the inner loop.

```yaml
CSF_GEOMETRY:
  sections:
    - name: S0
      z: 0.0
      polygons:
        - name: rect_ring_single_path
          weight: 1.0
          points:
            # Outer loop (positive contribution)
            - [0.0, 0.0]
            - [10.0, 0.0]
            - [10.0, 6.0]
            - [0.0, 6.0]
            - [0.0, 0.0]

            # Bridge to inner loop
            - [3.0, 2.0]

            # Inner loop (negative contribution)
            - [3.0, 4.0]
            - [7.0, 4.0]
            - [7.0, 2.0]
            - [3.0, 2.0]

            # Bridge back / closure
            - [0.0, 0.0]
```

The two-polygon form is generally easier to review and debug.  
The single-path form is compact, trivial once understood, and useful when a composite path is preferred (including simple `@cell`-oriented patterns).



This approach prioritizes determinism, reproducibility, and clarity over geometric convenience, forming a stable foundation for continuous sectional analysis.

## Summary

The CSF geometric model is based on a small set of explicit and verifiable rules:

- polygonal cross-sections,
- consistent topology,
- ruled-surface interpolation,
- strict orientation and ordering constraints.
- Nesting Semantics, Voids, and Equivalent Encodings

