"""
Prototype: continuous section field + property digestor + 2D/3D visualization

Assumptions (explicit):
- Two endpoint sections exist at z0 and z1.
- Same number of polygons in start/end.
- For each polygon: same number of vertices in start/end.
- Vertex ordering is already consistent (your matching is given/assumed).
- Polygons are simple enough for shoelace formulas (no self-intersections).

Dependencies: matplotlib (standard in most Python setups).
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Tuple, Dict, Optional, List
import math
import random
import warnings

import numpy as np
def export_opensees_discretized_sections(field: ContinuousSectionField, z_coords: list, E_val: float, filename: str = "opensees_sections.tcl"):
    """
    Exports a series of elastic sections to a .tcl file for OpenSees.
    This is useful for models where the user wants to discretize the tapered 
    beam into multiple segments with constant properties.
    """
    with open(filename, "w") as f:
        f.write("# --------------------------------------------------\n")
        f.write("# Sections generated by CSF (Continuous Section Field)\n")
        f.write(f"# Total sections: {len(z_coords)}\n")
        f.write("# --------------------------------------------------\n\n")
        
        for i, z in enumerate(z_coords):
            sec = field.section(z)
            # Perform full geometric analysis of the section at height z
            data = section_full_analysis(sec)
            
            # OpenSees syntax: section Elastic tag E A Iz Iy G J
            # G is estimated as E / (2 * (1 + nu)) -> approx E * 0.38
            G_val = E_val * 0.38
            
            line = (f"section Elastic {i+1} {E_val:.4e} {data['A']:.6f} "
                    f"{data['Ix']:.6f} {data['Iy']:.6f} {G_val:.4e} {data['K_torsion']:.6f}\n")
            f.write(line)
            
    print(f"Successfully exported {len(z_coords)} sections to {filename}")

def export_to_opensees_tcl(field, K_12x12, filename="csf_model.tcl"):
    """
      Generates an OpenSees-ready .tcl file that defines the nodes and the stiffness-matrix element computed by CSF.
    """
    z0 = field.z0
    z1 = field.z1
    
    with open(filename, "w") as f:
        f.write("# --------------------------------------------------\n")
        f.write("# Modello generato automaticamente da CSF (Continuous Section Field)\n")
        f.write("# --------------------------------------------------\n\n")
        
        # 1. Definition of the Nodes (Base and Top)
        # Syntax: node nodeTag x y z
        f.write(f"node 1 0.0 0.0 {z0}\n")
        f.write(f"node 2 0.0 0.0 {z1}\n\n")
        
        # 2. Definition of the stiffness matrix K in TCL list format
        f.write("set K {\n")
        for row in K_12x12:
            row_str = " ".join(f"{val:.8e}" for val in row)
            f.write(f"    {row_str}\n")
        f.write("}\n\n")
        
        # 3. Definition of the geometric transformation (required in OpenSees)
        f.write("geomTransf Linear 1 0 1 0\n\n")
        
        # 4. Definition of the MatrixBeamColumn element
        # Syntax: element matrixBeamColumn eleTag iNode jNode transfTag Klist
        f.write("element matrixBeamColumn 1 1 2 1 $K\n\n")
        
        f.write("puts \"CSF model successfully loaded: 2 nodes, 1 element (12×12 stiffness matrix)\"\n")

    print(f"File TCL generato con successo: {filename}")

    def assemble_element_stiffness_matrix(field: ContinuousSectionField, E_ref: float = 1.0, 
                                    nu: float = 0.3, n_gauss: int = 5) -> np.ndarray:
        """
        Assembles the complete 12x12 Timoshenko beam stiffness matrix with full EIxy coupling.
        
        DOF order (OpenSees compatible): [ux1,uy1,uz1,θx1,θy1,θz1 | ux2,uy2,uz2,θx2,θy2,θz2]
        Full asymmetric section support (EIxy coupling) + Saint-Venant torsion.
        """
        L = abs(field.z1 - field.z0)
        if L < 1e-9:
            raise ValueError("Element length must be positive")
        
        G_ref = E_ref / (2 * (1 + nu))
        
        # Gaussian quadrature points (n_gauss sufficient for exact integration)
        gauss_points = np.polynomial.legendre.leggauss(n_gauss)
        
        K = np.zeros((12, 12))
        
        for xi, weight in gauss_points:
            z_phys = ((field.z1 - field.z0) * xi + (field.z1 + field.z0)) / 2.0
            W = weight * (L / 2.0)
            
            # Sectional properties
            K_sec = section_stiffness_matrix(field.section(z_phys), E_ref=E_ref)
            props = section_full_analysis(field.section(z_phys))
            
            EA = K_sec[0, 0]
            EIx = K_sec[1, 1] 
            EIy = K_sec[2, 2]
            EIxy = K_sec[1, 2]
            GK = props['J'] * G_ref  # Correct Saint-Venant torsion
            
            # Integration coefficients (Euler-Bernoulli exact)
            c1 = 12 * W / L**3
            c2 = 6 * W / L**2  
            c3 = 4 * W / L
            c4 = 2 * W / L
            
            # AXIAL (DOF 0,6)
            axial = EA * W / L
            K[0,0] += axial; K[6,6] += axial
            K[0,6] -= axial; K[6,0] -= axial
            
            # TORSION (DOF 3,9) - Saint-Venant
            tors = GK * W / L
            K[3,3] += tors; K[9,9] += tors  
            K[3,9] -= tors; K[9,3] -= tors
            
            # FLEXURE YZ (about X) - DOF 1,5,7,11 [uy1,θz1,uy2,θz2]
            K[1,1] += c1*EIx; K[1,5] += c2*EIx; K[1,7] -= c1*EIx; K[1,11] += c2*EIx
            K[5,5] += c3*EIx; K[5,7] -= c2*EIx; K[5,11] += c4*EIx
            K[7,7] += c1*EIx; K[7,11] -= c2*EIx
            K[11,11] += c3*EIx
            
            # FLEXURE XZ (about Y) - DOF 2,4,8,10 [uz1,θy1,uz2,θy2] 
            K[2,2] += c1*EIy; K[2,4] -= c2*EIy; K[2,8] -= c1*EIy; K[2,10] -= c2*EIy
            K[4,4] += c3*EIy; K[4,8] += c2*EIy; K[4,10] += c4*EIy
            K[8,8] += c1*EIy; K[8,10] += c2*EIy
            K[10,10] += c3*EIy
            
            # FULL EIxy COUPLING (24 terms) - Bending-bending interaction
            # Node 1 rotations [uy1,uz1] = [1,2] couple with [θz1,θy1] = [5,4]
            K[1,2] += c1*EIxy; K[2,1] += c1*EIxy
            K[1,4] -= c2*EIxy; K[4,1] -= c2*EIxy  
            K[1,8] -= c1*EIxy; K[8,1] -= c1*EIxy
            K[1,10] -= c2*EIxy; K[10,1] -= c2*EIxy
            
            K[2,5] += c2*EIxy; K[5,2] += c2*EIxy
            K[4,5] += c4*EIxy; K[5,4] += c4*EIxy  # Corrected from 0.0
            K[2,7] -= c1*EIxy; K[7,2] -= c1*EIxy
            K[2,11] -= c2*EIxy; K[11,2] -= c2*EIxy
            
            K[5,8] -= c2*EIxy; K[8,5] -= c2*EIxy
            K[5,10] += c4*EIxy; K[10,5] += c4*EIxy
            K[7,4] -= c2*EIxy; K[4,7] -= c2*EIxy
            K[7,10] += c2*EIxy; K[10,7] += c2*EIxy
            
            K[11,4] += c2*EIxy; K[4,11] += c2*EIxy
            K[11,8] -= c2*EIxy; K[8,11] -= c2*EIxy
        
        # Final validation (reciprocity theorem)
        if not np.allclose(K, K.T, rtol=1e-10, atol=1e-12):
            warnings.warn("Minor asymmetry detected - enforcing symmetry", RuntimeWarning)
            K = (K + K.T) / 2.0
        
        # Physical bounds check
        if np.any(np.diag(K[:6]) < 0):
            raise ValueError("Negative diagonal stiffness detected")
            
        return K

    
def polygon_inertia_about_origin(poly: Polygon) -> Tuple[float, float, float]:
    """
    Second moments about the origin (0,0) using standard polygon formulas.
    Returns (Ix, Iy, Ixy) about origin, INCLUDING poly.weight.

    Notes:
    - Works for simple polygons (non self-intersecting).
    - Sign/orientation is handled by using signed cross; we then multiply by weight.
    - For holes, you can use negative weight or a separate convention.
    """
    verts = poly.vertices
    n = len(verts)

    Ix = 0.0
    Iy = 0.0
    Ixy = 0.0

    for i in range(n):
        x0, y0 = verts[i].x, verts[i].y
        x1, y1 = verts[(i + 1) % n].x, verts[(i + 1) % n].y
        cross = x0 * y1 - x1 * y0

        Ix += (y0 * y0 + y0 * y1 + y1 * y1) * cross
        Iy += (x0 * x0 + x0 * x1 + x1 * x1) * cross
        Ixy += (x0 * y1 + 2.0 * x0 * y0 + 2.0 * x1 * y1 + x1 * y0) * cross

    Ix *= (1.0 / 12.0)
    Iy *= (1.0 / 12.0)
    Ixy *= (1.0 / 24.0)

    # Apply weight; keep sign conventions consistent by using magnitude of orientation implicitly
    # For typical usage, we want weighted contributions. We take absolute values of Ix/Iy if polygon orientation flips.
    # Using signed formulas + abs for Ix/Iy tends to be robust for mixed orientations in prototypes.
    return (poly.weight * abs(Ix), poly.weight * abs(Iy), poly.weight * Ixy)

def integrate_volume(field: ContinuousSectionField) -> float:
    """
    Computes the total volume of a 3D ruled solid using high-precision 
    5-point Gaussian quadrature.
    """
    L = abs(field.z1 - field.z0)
    
    # 5-point Gaussian quadrature points and weights
    gauss_points = [
        (-0.9061798459, 0.2369268851),
        (-0.5384693101, 0.4786286705),
        ( 0.0,           0.5688888889),
        ( 0.5384693101, 0.4786286705),
        ( 0.9061798459, 0.2369268851)
    ]

    V = 0.0

    for xi, weight in gauss_points:
        # Map Gauss point from [-1, 1] to physical [z0, z1]
        z_phys = ((field.z1 - field.z0) * xi + (field.z1 + field.z0)) / 2.0
        
        # Get sectional area at the Gauss point
        section = field.section(z_phys)
        A = section_properties(section)["A"]
        
        # Accumulate weighted volume (detJ = L / 2)
        V += A * weight * (L / 2.0)

    return V

def section_full_analysis(section: Section):
    """
    Performs a comprehensive structural and geometric analysis of a cross-section.
    
    This function integrates primary geometric data with advanced derived properties, 
    including principal inertial axes, elastic section moduli for bending stress 
    estimation, and a refined torsional constant based on Saint-Venant's semi-empirical 
    approximation for shape-agnostic rigidity.
    """
    
    # -------------------------------------------------------------------------
    # 1. PRIMARY GEOMETRIC COMPUTATION
    # -------------------------------------------------------------------------
    # Calculate fundamental properties: Net Area (A), Centroid coordinates (Cx, Cy),
    # Global Moments of Inertia (Ix, Iy, Ixy), and the Polar Moment (J).
    # This step accounts for weighted polygons (e.g., negative weights for holes).
    props = section_properties(section)
    
    # -------------------------------------------------------------------------
    # 2. PRINCIPAL AXIS ANALYSIS
    # -------------------------------------------------------------------------
    # Compute principal moments of inertia (I1, I2) and the rotation angle (theta).
    # This identifies the orientation where the product of inertia is zero, 
    # crucial for analyzing unsymmetrical bending.
    derived = section_derived_properties(props)
    
    # -------------------------------------------------------------------------
    # 3. ELASTIC SECTION MODULI (W) - BENDING CAPACITY
    # -------------------------------------------------------------------------
    # To determine the maximum bending stress (sigma = M/W), we must find the 
    # distance to the "extreme fibers" (the points furthest from the centroid).
    
    # Extract all vertex coordinates from every polygon in the section
    all_x = [v.x for poly in section.polygons for v in poly.vertices]
    all_y = [v.y for poly in section.polygons for v in poly.vertices]
    
    # Compute the maximum perpendicular distance from the centroidal axes:
    # y_dist_max is used for bending about the X-axis (Top/Bottom fiber)
    y_dist_max = max(max(all_y) - props['Cy'], props['Cy'] - min(all_y))
    # x_dist_max is used for bending about the Y-axis (Left/Right fiber)
    x_dist_max = max(max(all_x) - props['Cx'], props['Cx'] - min(all_x))
    
    # Calculate Elastic Moduli: W = I / c_max.
    # A tolerance check (1e-12) prevents division by zero in degenerate geometries.
    props['Wx'] = props['Ix'] / y_dist_max if y_dist_max > 1e-12 else 0.0
    props['Wy'] = props['Iy'] / x_dist_max if x_dist_max > 1e-12 else 0.0
    
    # -------------------------------------------------------------------------
    # 4. TORSIONAL RIGIDITY (K) - SAINT-VENANT APPROXIMATION
    # -------------------------------------------------------------------------
    # For non-circular sections, the Polar Moment (J) significantly overestimates 
    # torsional stiffness because it fails to account for "warping" (axial 
    # deformation of the cross-section).
    
    A = props['A']
    J = props['J']
    
    props['K_torsion'] = 0.0

    
    # -------------------------------------------------------------------------
    # 5. DATA CONSOLIDATION
    # -------------------------------------------------------------------------
    # Merge the primary properties with the derived principal axis data into 
    # a single comprehensive dictionary for downstream structural solvers.
    return {**props, **derived}

def polygon_statical_moment(poly: Polygon, y_axis: float) -> float:
    """
    Computes the First Moment of Area (Statical Moment), Q, of a SINGLE polygon 
    relative to a specific horizontal axis (y_axis).
    
    TECHNICAL NOTES:
    - Formula: Q = Area * (y_centroid - y_axis)
    - Sign Convention: Positive if the polygon centroid is above the reference axis.
    - Homogenization: Uses weighted area to account for holes or material density.
    """
    area_i, (cx_i, cy_i) = polygon_area_centroid(poly)
    # Distance from the polygon centroid to the reference axis
    d_y = cy_i - y_axis
    return area_i * d_y

def section_statical_moment_partial(section: Section, y_cut: float, reference_axis: float = None) -> float:
    """
    Computes the partial Statical Moment (Q) for the portion of the section 
    located ABOVE the vertical coordinate y_cut using geometric clipping.
    """
    props = section_properties(section)
    y_na = reference_axis if reference_axis is not None else props['Cy']
    
    q_total = 0.0
    
    for poly in section.polygons:
        verts = poly.vertices
        n = len(verts)
        new_verts = []
        
        # --- ALGORITMO DI CLIPPING (Sutherland-Hodgman semplificato per y_cut) ---
        for i in range(n):
            p1 = verts[i]
            p2 = verts[(i + 1) % n]
            
            # Case 1: Both points are above the cut
            if p1.y >= y_cut and p2.y >= y_cut:
                new_verts.append(p2)
            
            # Case 2: p1 is above and p2 is below → add the intersection point
            elif p1.y >= y_cut and p2.y < y_cut:
                t = (y_cut - p1.y) / (p2.y - p1.y)
                x_int = p1.x + t * (p2.x - p1.x)
                new_verts.append(Pt(x_int, y_cut))
            
            # Case 3: p1 is below and p2 is above → add the intersection point and p
            elif p1.y < y_cut and p2.y >= y_cut:
                t = (y_cut - p1.y) / (p2.y - p1.y)
                x_int = p1.x + t * (p2.x - p1.x)
                new_verts.append(Pt(x_int, y_cut))
                new_verts.append(p2)
                
            # Case 4: Both points are below → add nothing
        
        # if a new polygon has been created (the upper portion)
        if len(new_verts) >= 3:
            clipped_poly = Polygon(vertices=tuple(new_verts), weight=poly.weight)
            # CCompute the area and centroid of the cut portion
            area_part, (_, cy_part) = polygon_area_centroid(clipped_poly)
            # Q = Area_part × (centroid_y_part − neutral_axis_y)
            q_total += area_part * (cy_part - y_na)
            
    return q_total


def section_derived_properties(props: Dict[str, float]) -> Dict[str, float]:
    """
    Computes derived structural properties including principal moments of inertia,
    principal axis rotation, and radius of gyration.
    """
    Ix = props['Ix']
    Iy = props['Iy']
    Ixy = props['Ixy']

    # Calculate Mohr's Circle parameters
    avg = (Ix + Iy) / 2
    diff = (Ix - Iy) / 2
    # R is the radius of Mohr's Circle: R = sqrt(((Ix - Iy)/2)^2 + Ixy^2)
    R = math.sqrt(diff**2 + Ixy**2)

    # --- NUMERICAL STABILITY & ISOTROPY CHECK ---
    # For perfectly symmetric sections (like circles or squares), Ix = Iy and Ixy = 0.
    # This creates a mathematical singularity where the principal angle is indeterminate
    # (Mohr's Circle collapses to a single point). 
    # To prevent numerical noise (1e-16) from producing erratic rotation angles,
    # we detect if the radius R is negligible compared to the magnitude of inertia.
    # If isotropic, the principal angle is set to 0.0 by engineering convention.
    if R < abs(avg) * 1e-14: 
        theta = 0.0
    else:
        # Standard calculation for the angle of the principal X-axis
        theta = 0.5 * math.atan2(-2 * Ixy, Ix - Iy)
    # --------------------------------------------

    return {
        'I1': avg + R,  # Major principal moment of inertia
        'I2': avg - R,  # Minor principal moment of inertia
        'theta_rad': theta,
        'theta_deg': math.degrees(theta),
        'rx': math.sqrt(Ix / props['A']) if props['A'] > 0 else 0,
        'ry': math.sqrt(Iy / props['A']) if props['A'] > 0 else 0,
    }

def _get_triangle_gauss_points(v0: Pt, v1: Pt, v2: Pt):
    """
    Computes Gaussian sampling points and weights for a triangular domain.

    TECHNICAL SUMMARY:
    This function implements a 3-point Gaussian Quadrature rule for 2D numerical 
    integration over a triangle defined by vertices v0, v1, and v2. It is the 
    computational engine used to determine mass and stiffness properties 
    (Area, Inertia, Elasticity) of complex polygonal sections.

    MATHEMATICAL FORMULATION:
    1. Local Area Calculation: 
       The function calculates the triangle's area using the Shoelace formula 
       (cross-product method): 
       Area = 0.5 * |x0(y1 - y2) + x1(y2 - y0) + x2(y0 - y1)|

    2. Barycentric Coordinate Mapping:
       It utilizes optimal internal sampling points (r, s, t) where t = 1 - r - s.
       The coordinates [(1/6, 1/6), (2/3, 1/6), (1/6, 2/3)] are chosen for 
       Quadratic Precision, meaning they integrate any quadratic polynomial 
       (like y^2 or x*y used in Inertia calculations) exactly.

    3. Transformation to Cartesian Space:
       The local coordinates are mapped to the global (x, y) system using:
       P = r*V0 + s*V1 + t*V2

    4. Weight Assignment:
       Each point is assigned a weight equal to (1/3 * Area), ensuring that 
       the sum of weights equals the total triangular area.

    RETURNS:
       A list of tuples (x, y, weight) representing the discrete integration points.
    """
    # Barycentric coordinates (r, s, t) with t = 1 - r - s
    # Optimal interior points for quadratic accuracy
    coords = [(1/6, 1/6), (2/3, 1/6), (1/6, 2/3)]
    w_gauss = 1/3 
    
    # Triangle area (local Shoelace formula)
    area = 0.5 * abs(v0.x*(v1.y - v2.y) + v1.x*(v2.y - v0.y) + v2.x*(v0.y - v1.y))
    
    points = []
    for r, s in coords:
        t = 1 - r - s
        x = r*v0.x + s*v1.x + t*v2.x
        y = r*v0.y + s*v1.y + t*v2.y
        points.append((x, y, w_gauss * area))
    return points

def section_stiffness_matrix(section: Section, E_ref: float = 1.0) -> np.ndarray:
    """

 Assembles the 3x3 constitutive stiffness matrix relating generalized 
    strains to internal forces (N, Mx, My).

    TECHNICAL SUMMARY:
    This function performs a numerical integration over the composite 
    polygonal domain to compute the sectional stiffness properties relative 
    to the global origin (0,0). It accounts for multi-material homogenization 
    via the polygon weighting system.

    STIFFNESS MATRIX FORMULATION:
    The resulting matrix K maps the axial strain (epsilon) and curvatures 
    (kappa_x, kappa_y) to the Resultant Normal Force (N) and Bending Moments (Mx, My):
    
        [ N  ]   [ EA    ESx   -ESy  ] [ epsilon ]
        [ Mx ] = [ ESx   EIxx  -EIxy ] [ kappa_x ]
        [ My ]   [ -ESy -EIxy   EIyy ] [ kappa_y ]

    COMPUTATIONAL STRATEGY:
    1. Fan Triangulation: 
       Each polygon is decomposed into triangles using a "fan" approach, 
       with the first vertex (v0) acting as the common pivot.
       
    2. Numerical Integration (Gauss Quadrature):
       For each triangular sub-domain, the function calls the Gaussian 
       integrator to retrieve optimal sampling points.
       
    3. Contribution Mapping:
       At each Gauss point (x, y) with differential area dA:
       - Axial Stiffness (EA): Σ E * dA
       - First Moments (ESx, ESy): Σ E * y * dA and Σ E * x * dA
       - Second Moments (EIxx, EIyy, EIxy): Σ E * y^2 * dA, Σ E * x^2 * dA, 
         and Σ E * x * y * dA.

    4. Homogenization:
       The 'poly.weight' parameter scales the reference Young's Modulus (E_ref), 
       allowing for the modeling of hollow sections (negative weights) or 
       composite structures with varying material stiffness.

    5. Symmetrization:
       Enforces the Maxwell-Betti reciprocal theorem by ensuring K[i,j] = K[j,i].

    RETURNS:
       A 3x3 NumPy array representing the cross-sectional stiffness tensor.   

    """
    # Initialize the matrix terms:
    # [ EA   ESx  -ESy ]
    # [ ESx  EIxx -EIxy ]
    # [ -ESy -EIxy EIyy ]
    K = np.zeros((3, 3))

    for poly in section.polygons:
        val_E = poly.weight * E_ref # Polygon weight * Elastic modulus
        verts = poly.vertices
        
        # Fan triangulation (v0 is the pivot)
        v0 = verts[0]
        for i in range(1, len(verts) - 1):
            v1, v2 = verts[i], verts[i+1]
            gauss_pts = _get_triangle_gauss_points(v0, v1, v2)
            
            for x, y, dA in gauss_pts:
                contribution = val_E * dA
                
                K[0, 0] += contribution              # EA
                K[0, 1] += contribution * y          # ESx
                K[0, 2] += contribution * (-x)       # -ESy
                
                K[1, 1] += contribution * y**2       # EIxx
                K[1, 2] += contribution * (-x * y)   # -EIxy
                
                K[2, 2] += contribution * x**2       # EIyy

    # Symmetrization
    K[1, 0] = K[0, 1]
    K[2, 0] = K[0, 2]
    K[2, 1] = K[1, 2]
    
    return K


def _segments_intersect(p1, p2, p3, p4) -> bool:
    '''
    Determines if two finite line segments (p1-p2 and p3-p4) intersect in a 2D plane.

    TECHNICAL SUMMARY:
    This function implements a robust geometric intersection test based on the 
    'Orientation Test' (cross-product method). It is primarily used to detect 
    self-intersections in homogenized polygons, ensuring the topological integrity 
    of the cross-sectional boundaries.

    MATHEMATICAL FORMULATION:
    1. Orientation Primitive:
       The inner 'orient' function computes the signed area of the triangle formed 
       by points (a, b, c). 
       - If Result > 0: The sequence (a, b, c) is Counter-Clockwise (CCW).
       - If Result < 0: The sequence is Clockwise (CW).
       - If Result = 0: The points are Collinear.

    2. Relative Orientation Logic:
       For two segments to intersect, the endpoints of each segment must lie on 
       opposite sides of the line defined by the other segment.
       - o1, o2 check points p3 and p4 relative to line p1-p2.
       - o3, o4 check points p1 and p2 relative to line p3-p4.

    3. Intersection Criterion:
       The condition (o1 * o2 < 0) and (o3 * o4 < 0) identifies a 'Proper Intersection'.
       This occurs when the endpoints strictly straddle the opposing lines, 
       excluding collinear overlaps or shared endpoints to maintain computational 
       stability during polygon validation.

    APPLICABILITY IN RULED SURFACE MODELING:
    By preventing self-intersecting polygons, this function ensures that the 
    Shoelace formula and Gaussian integration yield physically consistent results 
    for the area and inertia of the tower sections.

    RETURNS:
       - True: If segments p1-p2 and p3-p4 intersect.
       - False: Otherwise.

    '''

    def orient(a, b, c):
        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)

    o1 = orient(p1, p2, p3)
    o2 = orient(p1, p2, p4)
    o3 = orient(p3, p4, p1)
    o4 = orient(p3, p4, p2)

    return (o1 * o2 < 0) and (o3 * o4 < 0)


def polygon_has_self_intersections(poly: Polygon) -> bool:
    verts = poly.vertices
    n = len(verts)

    for i in range(n):
        a1 = verts[i]
        a2 = verts[(i + 1) % n]

        for j in range(i + 2, n):
            # skip adjacent edges and the closing edge
            if j == i or (j + 1) % n == i:
                continue

            b1 = verts[j]
            b2 = verts[(j + 1) % n]

            if _segments_intersect(a1, a2, b1, b2):
                return True

    return False



# -------------------------
# Geometry primitives
# -------------------------

@dataclass(frozen=True)
class Pt:
    x: float
    y: float

    def lerp(self, other: "Pt", t: float) -> "Pt":
        return Pt(
            (1.0 - t) * self.x + t * other.x,
            (1.0 - t) * self.y + t * other.y
        )


@dataclass(frozen=True)
class Polygon:
    vertices: Tuple[Pt, ...]
    weight: float = 1.0   # Homogenization coefficient, can be negative for holes
    name: str = ""        # Optional label / ID

    def __post_init__(self) -> None:
        """
        Validation steps executed automatically after object initialization.
        """
        # 1. Check for minimum number of vertices
        if len(self.vertices) < 3:
            raise ValueError(f"Polygon '{self.name}' must have at least 3 vertices.")

        # 2. Check for Counter-Clockwise (CCW) orientation
        # We use the Shoelace formula to calculate the signed area (a2).
        # A positive result indicates CCW, a negative result indicates CW.
        verts = self.vertices
        n = len(verts)
        a2 = 0.0
        for i in range(n):
            x0, y0 = verts[i].x, verts[i].y
            x1, y1 = verts[(i + 1) % n].x, verts[(i + 1) % n].y
            a2 += (x0 * y1 - x1 * y0)
        
        # If a2 is negative, the winding order is Clockwise (CW).
        if a2 < 0:
            raise ValueError(
                f"GEOMETRIC ERROR: Polygon '{self.name}' is defined in Clockwise (CW) order. "
                f"All polygons must be defined in Counter-Clockwise (CCW) order to ensure "
                f"consistency in first and second-order moments. "
                f"Please use 'weight={self.weight}' to represent voids instead of flipping the vertices."
            )

@dataclass(frozen=True)
class Section:
    polygons: Tuple[Polygon, ...]
    z: float
def poly_from_string(s: str, weight: float = 1.0, name: str = "") -> Polygon:
    """
    Utility: build a Polygon from a string like:
      "-0.5,-0.5  0.5,-0.5  0.5,0.5  -0.5,0.5"
    """
    pts = []
    for token in s.split():
        x_str, y_str = token.split(",")
        pts.append(Pt(float(x_str), float(y_str)))
    return Polygon(vertices=tuple(pts), weight=weight, name=name)

# -------------------------
# Core: Continuous section field (geometry-only)
# -------------------------

class ContinuousSectionField:
    """
    Geometry-only object:
    - stores two endpoint sections (at z0 and z1)
    - returns intermediate Section at any z via linear interpolation of corresponding vertices
    """


    def __init__(self, section0: Section, section1: Section):
            
            if len(section0.polygons) != len(section1.polygons):
                raise ValueError(
                    f"Mismatch: section0 has {len(section0.polygons)} polygons, "
                    f"but section1 has {len(section1.polygons)} polygons."
            )

            if section0.z == section1.z:
                raise ValueError("Sections must be at different z coordinates.")

            self.s0 = section0
            self.s1 = section1

            # single source of truth
            self.z0 = section0.z
            self.z1 = section1.z

            self._validate_inputs()

    def _validate_inputs(self) -> None:
        if len(self.s0.polygons) != len(self.s1.polygons):
            raise ValueError("Start/end sections must have the same number of polygons.")

        for i, (p0, p1) in enumerate(zip(self.s0.polygons, self.s1.polygons)):
            if len(p0.vertices) != len(p1.vertices):
                raise ValueError(
                    f"Polygon index {i} has different vertex counts: "
                    f"{len(p0.vertices)} vs {len(p1.vertices)}"
                )

    def _to_t(self, z: float) -> float:
        z = float(z)
        if not (min(self.z0, self.z1) <= z <= max(self.z0, self.z1)):
            raise ValueError(f"z={z} is outside [{self.z0}, {self.z1}].")
        return (z - self.z0) / (self.z1 - self.z0)

    def section(self, z: float) -> Section:
        t = self._to_t(z)

        polys: List[Polygon] = []
        for p0, p1 in zip(self.s0.polygons, self.s1.polygons):
            verts = tuple(v0.lerp(v1, t) for v0, v1 in zip(p0.vertices, p1.vertices))
            # keep weight/name from p0 by default (can be changed to another policy)
            #polys.append(Polygon(vertices=verts, weight=p0.weight, name=p0.name))

            poly = Polygon(vertices=verts, weight=p0.weight, name=p0.name)

            if polygon_has_self_intersections(poly):
                warnings.warn(
                    f"Self-intersection detected in polygon '{poly.name}' at z={z:.3f}",
                    RuntimeWarning
                )

            polys.append(poly)

        return Section(polygons=tuple(polys), z=float(z))


# -------------------------
# Digestor: Section properties (2D polygon-based)
# -------------------------

def _polygon_signed_area_and_centroid(poly: Polygon) -> Tuple[float, Tuple[float, float]]:
    """
    Shoelace. Returns signed area (can be negative depending on orientation) and centroid.
    """
    verts = poly.vertices
    n = len(verts)

    a2 = 0.0  # 2*Area signed
    cx6 = 0.0
    cy6 = 0.0

    for i in range(n):
        x0, y0 = verts[i].x, verts[i].y
        x1, y1 = verts[(i + 1) % n].x, verts[(i + 1) % n].y
        cross = x0 * y1 - x1 * y0
        a2 += cross
        cx6 += (x0 + x1) * cross
        cy6 += (y0 + y1) * cross

    if abs(a2) < 1e-14:
        # Degenerate polygon
        return 0.0, (0.0, 0.0)

    A = 0.5 * a2
    Cx = cx6 / (3.0 * a2)  # because centroid formula uses 6A, and 6A=3*a2
    Cy = cy6 / (3.0 * a2)
    return A, (Cx, Cy)


def polygon_area_centroid(poly: Polygon) -> Tuple[float, Tuple[float, float]]:
    """
    Computes the signed area and geometric centroid of a non-self-intersecting polygon.

    TECHNICAL SUMMARY:
    This function implements the Surveyor's Formula (Shoelace Algorithm), 
    derived from Green's Theorem, to integrate area and first moments over 
    a planar polygonal domain. It is designed to handle both "solid" (counter-clockwise) 
    and "void" (clockwise) polygons to model hollow sections like wind turbine towers.

    MATHEMATICAL FORMULATION:
    1. Signed Area (A):
       The area is computed as the sum of cross-products of vertex vectors:
       A = 0.5 * Σ (x_i * y_{i+1} - x_{i+1} * y_i)
       The sign of the area indicates the vertex winding order:
       - Positive: Counter-Clockwise (CCW).
       - Negative: Clockwise (CW).

    2. Geometric Centroid (Cx, Cy):
       The coordinates of the centroid (center of area) are derived from the 
       first moments of area (Qx, Qy):
       Cx = (1 / 6A) * Σ (x_i + x_{i+1}) * (x_i * y_{i+1} - x_{i+1} * y_i)
       Cy = (1 / 6A) * Σ (y_i + y_{i+1}) * (x_i * y_{i+1} - x_{i+1} * y_i)

    COMPUTATIONAL ROBUSTNESS:
    - Degeneracy Handling: Includes a threshold check (1e-14) to identify 
      degenerate polygons (lines or points) and prevent division-by-zero errors.
    - Consistency: Since it utilizes a cyclic vertex indexing [(i + 1) % n], 
      it ensures a closed-loop integration regardless of vertex count.

    APPLICABILITY IN RULED SURFACE MODELING:
    By returning the signed area, this function allows for seamless 
    homogenization. When a void (e.g., the inner diameter of a tower) is 
    modeled with an opposite winding order or negative weight, the integration 
    correctly subtracts its properties from the total section digest.

    RETURNS:
       - Area: Signed area of the polygon [L²].
       - Centroid: Tuple (Cx, Cy) representing the geometric center [L].
    """
    A_signed, (Cx, Cy) = _polygon_signed_area_and_centroid(poly)
    A_mag = abs(A_signed)
    return poly.weight * A_mag, (Cx, Cy)


def section_data(field: ContinuousSectionField, z: float) -> dict:
    """
    Extracts the complete geometric state and physical properties of a section 
    at a specific longitudinal coordinate (z).

    TECHNICAL SUMMARY:
    This function acts as a high-level accessor for the Continuous Section Field. 
    It performs a synchronized extraction of both the interpolated boundary 
    geometry and the corresponding integral properties (Area, First/Second Moments). 
    It provides a discrete "snapshot" of a 3D ruled solid at any point along 
    its integration path.

    WORKFLOW AND DATA ARCHITECTURE:
    1. Geometric Reconstruction:
       The function first invokes the internal Linear Interpolation (LERP) 
       mechanism to reconstruct the homogenized polygonal boundaries at 
       coordinate 'z'. This ensures topological consistency across the 
       longitudinal domain.

    2. Property Integration:
       Once the geometry is established, the 'section_properties' engine 
       is executed to compute the sectional digest. This involves:
       - Zeroth Moment: Area (A).
       - First Moments: Centroidal coordinates (Cx, Cy).
       - Second Moments: Moments of inertia (Ix, Iy, Ixy) and the Polar 
         Moment (J).

    3. Data Encapsulation:
       The results are packaged into a dictionary structure, decoupling the 
       raw geometric data (vertices/polygons) from the derived structural 
       parameters.

    APPLICABILITY:
    This function is the standard interface for structural analysis routines 
    that require local stiffness or stress evaluation at specific points 
    along a non-prismatic member.

    RETURNS:
       A dictionary containing:
       - 'section': The Section object (polygonal boundaries at z).
       - 'properties': A dictionary of computed geometric constants.
    """

    section = field.section(z)
    props = section_properties(section)

    return {
        "section": section,     # geometria completa
        "properties": props,    # A, Cx, Cy, Ix, Iy, Ixy, J
    }

def section_properties(section: Section) -> Dict[str, float]:
    """
    Computes the integral geometric properties for a composite cross-section.

    TECHNICAL SUMMARY:
    This function performs a multi-pass integration over a set of weighted 
    polygons to derive the global geometric constants. It manages homogenization 
    by algebraically summing contributions, allowing for the representation of 
    complex domains with voids or varying material densities.

    ALGORITHMIC WORKFLOW:
    1. First-Order Moments (Area and Centroid):
       - Aggregates the weighted area (A) and the first moments of area (Qx, Qy) 
         for all constituent polygons.
       - Locates the global centroid (Cx, Cy) of the composite section.

    2. Second-Order Moments (Inertia about Origin):
       - Computes the area moments of inertia (Ix, Iy) and the product of 
         inertia (Ixy) relative to the global coordinate origin (0,0).

    3. Translation of Axes (Parallel Axis Theorem):
       - Applies the Huygens-Steiner Theorem to shift the moments of inertia 
         from the global origin to the newly calculated centroidal axes:
         I_centroid = I_origin - A * d^2
       - This transformation ensures the properties are intrinsic to the 
         section's geometry, independent of the global coordinate system.

    4. Polar Moment Extraction:
       - Derives the Polar Second Moment of Area (J) about the centroid as 
         the sum of the orthogonal centroidal moments (Ix + Iy).

    RETURNS:
       A comprehensive dictionary containing:
       - 'A': Net weighted area.
       - 'Cx', 'Cy': Centroidal coordinates.
       - 'Ix', 'Iy', 'Ixy': Second moments of area about centroidal axes.
       - 'J': Polar moment of area.
    """
    # First pass: area + centroid
    A_tot = 0.0
    Cx_num = 0.0
    Cy_num = 0.0

    poly_cache = []
    for poly in section.polygons:
        A_i, (cx_i, cy_i) = polygon_area_centroid(poly)
        A_tot += A_i
        Cx_num += A_i * cx_i
        Cy_num += A_i * cy_i
        poly_cache.append((poly, A_i, cx_i, cy_i))

    if abs(A_tot) < 1e-14:
        raise ValueError("Composite area is ~0; cannot compute centroid/properties reliably.")

    Cx = Cx_num / A_tot
    Cy = Cy_num / A_tot

    # Second pass: inertia about origin then shift to centroid
    Ix_o = 0.0
    Iy_o = 0.0
    Ixy_o = 0.0

    for poly, _, _, _ in poly_cache:
        ix, iy, ixy = polygon_inertia_about_origin(poly)
        Ix_o += ix
        Iy_o += iy
        Ixy_o += ixy

    # Parallel axis theorem to centroid
    Ix_c = Ix_o - A_tot * (Cy * Cy)
    Iy_c = Iy_o - A_tot * (Cx * Cx)
    Ixy_c = Ixy_o - A_tot * (Cx * Cy)

    J = Ix_c + Iy_c

    return {
        "z": section.z,
        "A": A_tot,
        "Cx": Cx,
        "Cy": Cy,
        "Ix": Ix_c,
        "Iy": Iy_c,
        "Ixy": Ixy_c,
        "J": J,
    }


# -------------------------
# Visualization helpers
# -------------------------

def _set_axes_equal_3d(ax) -> None:
    """
    Configures 3D axis limits to perform a 'selective zoom' and maintain 
    consistent aspect ratios for cross-sectional visualization.

    TECHNICAL SUMMARY:
    This function normalizes the viewport of a Matplotlib 3D projection. 
    It ensures that the horizontal plane (X-Y) is scaled isotropically 
    (equal aspect ratio) to prevent geometric distortion of the sections, 
    while allowing the longitudinal axis (Z) to retain its full physical 
    extent for structural context.

    ALGORITHMIC LOGIC:
    1. Limit Extraction:
       Retrieves current bounding box limits for X, Y, and Z dimensions 
       to determine the object's spatial center.

    2. Planar Isotropic Scaling:
       Calculates a maximum radius based on the spans of X and Y. By 
       applying this radius symmetrically to both horizontal axes, the 
       function ensures that circles or ellipses appear without 
       eccentricity distortion.

    3. Longitudinal Preservation:
       Unlike standard 'equal axis' commands, this logic preserves the 
       original Z-limits. This is crucial for high-aspect-ratio solids, 
       ensuring the entire height is visible within the frame.

    4. Box Aspect Ratio:
       Sets the 'box_aspect' to (1, 1, 2) to force a vertical emphasis, 
       making slender solids visually representative of their physical 
       proportions.
    """
    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()

    # Calcoliamo i centri
    x_mid = sum(x_limits) / 2.0
    y_mid = sum(y_limits) / 2.0
    z_mid = sum(z_limits) / 2.0

    # Determine the maximum range for the X-Y plane only
    # (Ensures horizontal geometry fills the space without distortion)
    x_range = abs(x_limits[1] - x_limits[0])
    y_range = abs(y_limits[1] - y_limits[0])
    radius_xy = 0.5 * max(x_range, y_range)

    # Apply centered isotropic zoom on X and Y
    ax.set_xlim3d([x_mid - radius_xy, x_mid + radius_xy])
    ax.set_ylim3d([y_mid - radius_xy, y_mid + radius_xy])
    
    # Maintain physical Z-limits for the longitudinal axis
    ax.set_zlim3d(z_limits)

    # Force a visual box aspect to emphasize verticality
    ax.set_box_aspect((1, 1, 2))


class Visualizer:
    """
    Adds 2D and 3D plotting utilities on top of a ContinuousSectionField.
    """

    def __init__(self, field: ContinuousSectionField):
        self.field = field




    def plot_section_2d(self, z: float, show_ids: bool = True, show_weights: bool = True,
                        title: Optional[str] = None, ax=None):
        """
        Disegna la sezione 2D con descrizioni negli angoli:
        - Poligono 0: In alto a destra
        - Poligono 1: In basso a sinistra
        """
        import matplotlib.pyplot as plt

        sec = self.field.section(z)
        if ax is None:
            fig, ax = plt.subplots()

        for idx, poly in enumerate(sec.polygons):
            xs = [p.x for p in poly.vertices] + [poly.vertices[0].x]
            ys = [p.y for p in poly.vertices] + [poly.vertices[0].y]
            
            # Disegno del poligono e recupero colore
            line, = ax.plot(xs, ys, linewidth=1.5, zorder=2)
            color = line.get_color()

            if show_ids or show_weights:
                # Costruzione stringa info
                parts = []
                if show_ids: parts.append(f"#{idx}")
                if show_weights: parts.append(f"w={poly.weight:g}")
                if poly.name: parts.append(poly.name)
                label_text = "\n".join(parts)

                # Logica di posizionamento negli angoli
                if idx == 0:
                    # ALTO A DESTRA (Coordinate 0.95, 0.95 relative agli assi)
                    x_pos, y_pos = 0.95, 0.95
                    ha, va = 'right', 'top'
                elif idx == 1:
                    # BASSO A SINISTRA (Coordinate 0.05, 0.05 relative agli assi)
                    x_pos, y_pos = 0.05, 0.05
                    ha, va = 'left', 'bottom'
                else:
                    # Eventuali altri poligoni rimangono al centroide per default
                    _, (cx, cy) = polygon_area_centroid(poly)
                    ax.text(cx, cy, label_text, color=color, ha='center', va='center',
                            bbox=dict(facecolor='white', alpha=0.7, edgecolor=color))
                    continue

                # Stampa l'etichetta nell'angolo usando transform=ax.transAxes
                ax.text(
                    x_pos, y_pos, label_text,
                    transform=ax.transAxes, # Coordinate relative al riquadro (0-1)
                    fontsize=10,
                    fontweight='bold',
                    color=color,
                    ha=ha, va=va,
                    zorder=3,
                    bbox=dict(
                        facecolor='white', 
                        alpha=0.85, 
                        edgecolor=color, 
                        boxstyle='round,pad=0.4'
                    )
                )

        ax.set_aspect("equal", adjustable="box")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.grid(True, linestyle=':', alpha=0.5, zorder=1)

        if title is None:
            title = f"Section at z={z:g}"
        ax.set_title(title)

        return ax




    def plot_section_2d2remove(self, z: float, show_ids: bool = True, show_weights: bool = True,
                        title: Optional[str] = None, ax=None):
        """
        Draw 2D section at z in perfect scale (equal aspect).
        Annotates polygon index and weight at each polygon centroid.
        """
        import matplotlib.pyplot as plt

        sec = self.field.section(z)

        if ax is None:
            fig, ax = plt.subplots()

        for idx, poly in enumerate(sec.polygons):
            xs = [p.x for p in poly.vertices] + [poly.vertices[0].x]
            ys = [p.y for p in poly.vertices] + [poly.vertices[0].y]
            ax.plot(xs, ys)

            # annotate at centroid
            if show_ids or show_weights:
                _, (cx, cy) = polygon_area_centroid(poly)
                parts = []
                if show_ids:
                    parts.append(f"#{idx}")
                if show_weights:
                    parts.append(f"w={poly.weight:g}")
                if poly.name:
                    parts.append(poly.name)
                ax.text(cx, cy, "  ".join(parts), fontsize=9)

        ax.set_aspect("equal", adjustable="box")
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.grid(True, linewidth=0.3)

        if title is None:
            title = f"Section at z={z:g}"
        ax.set_title(title)

        return ax
    

    def plot_volume_3d(self, show_end_sections: bool = True, line_percent: float = 100.0,
                       seed: int = 0, title: str = "Ruled volume (vertex-connection lines)", ax=None):
        """
        Draw the 3D ruled "skeleton":
        - endpoint section outlines (optional)
        - straight lines connecting corresponding vertices (ruled generators)
        - ability to display only a percentage of those lines for readability

        line_percent:
          0..100 : percentage of connection lines shown (random subsample).
        """
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D  # noqa: F401 (needed by mpl)

        if not (0.0 <= line_percent <= 100.0):
            raise ValueError("line_percent must be within [0, 100].")
            
        # 2. AXES INITIALIZATION
        # If no existing axis is provided, create a new 3D figure with a default perspective.
        if ax is None:
            fig = plt.figure()
            ax = fig.add_subplot(111, projection="3d")
            ax.view_init(elev=15, azim=120)

        # 3. GEOMETRY EXTRACTION
        # Get endpoint sections at the field's start (z0) and end (z1).
        z0, z1 = self.field.z0, self.field.z1
        s0 = self.field.section(z0)
        s1 = self.field.section(z1)

        # 4. DRAW END SECTIONS
        # If show_end_sections is True, plot the perimeter of all polygons at Z0 and Z1.
        # This helps visualize the boundary transition of the ruled
        if show_end_sections:
            for sec in (s0, s1):
                for poly in sec.polygons:
                    xs = [p.x for p in poly.vertices] + [poly.vertices[0].x]
                    ys = [p.y for p in poly.vertices] + [poly.vertices[0].y]
                    zs = [sec.z] * len(xs)
                    ax.plot(xs, ys, zs)
        # 5. BUILD GENERATOR LINES
        # Create a list of all straight lines (ruled generators) connecting
        # each vertex in the start section to its corresponding vertex in the end section.
        all_lines = []
        for p0, p1 in zip(s0.polygons, s1.polygons):
            for v0, v1 in zip(p0.vertices, p1.vertices):
                all_lines.append((v0, v1))

        # 6. SUBSAMPLING (Visual Clarity)
        # If line_percent < 100, we randomly select a subset of lines to avoid visual clutter.
        # Using a fixed 'seed' ensures the same set of lines is picked every time (reproducibility).
        if line_percent < 100.0:
            rng = random.Random(seed)
            k = int(math.ceil(len(all_lines) * (line_percent / 100.0)))
            k = max(0, min(k, len(all_lines)))
            all_lines = rng.sample(all_lines, k)

        # 7. PLOTTING
        # Draw the connection lines between the two Z-planes.
        for v0, v1 in all_lines:
            ax.plot([v0.x, v1.x], [v0.y, v1.y], [z0, z1])

        # Draw axes labels
        ax.set_xlabel("X")
        ax.set_ylabel("Y")
        ax.set_zlabel("Z")
        ax.set_title(title)

        # Improve scaling
        _set_axes_equal_3d(ax)
        return ax


# ============================================================
# Example: Continuous Section Field – Static Properties Demo
# ============================================================
#
# This script demonstrates how to:
# - define polygonal cross-sections,
# - interpolate them along a longitudinal axis (Z),
# - compute geometric and static properties,
# - visualize both 2D sections and the 3D ruled solid.
#
# The example uses a tapered T-section composed of:
# - a flange polygon
# - a web polygon
#
# Coordinate system:
#   X → horizontal
#   Y → vertical
#   Z → longitudinal
#
# NOTE:
# A negative centroid Y-coordinate (Cy) is expected in this example
# because most of the section area lies below the global X-axis.
#
# ============================================================


if __name__ == "__main__":

    # --------------------------------------------------------
    # 1. DEFINE START SECTION (Z = 0)
    # --------------------------------------------------------
    # The start section is a T-shape composed of two polygons:
    # - flange (horizontal plate)
    # - web (vertical plate)


    # Define start polygons (T-Section at Z=0)
    poly0_start = Polygon(
        vertices=(Pt(-1, -0.2), Pt(1, -0.2), Pt(1, 0.2), Pt(-1, 0.2)),
        weight=1.0,
        name="flange",
    )
    poly1_start = Polygon(
        vertices=(Pt(-0.2, -1.0), Pt(0.2, -1.0), Pt(0.2, 0.2), Pt(-0.2, 0.2)),
        weight=1.0,
        name="web",
    )

    # --------------------------------------------------------
    # 2. DEFINE END SECTION (Z = 10)
    # --------------------------------------------------------
    # The flange remains unchanged.
    # The web depth increases linearly from 1.0 to 2.5,
    # producing a tapered T-section along the Z-axis.

    poly0_end = Polygon(
        vertices=(Pt(-1, -0.2), Pt(1, -0.2), Pt(1, 0.2), Pt(-1, 0.2)),
        weight=1.0,
        name="flange",
    )
    poly1_end = Polygon(
        vertices=(Pt(-0.2, -2.5), Pt(0.2, -2.5), Pt(0.2, 0.2), Pt(-0.2, 0.2)),
        weight=1.0,
        name="web",
    )

    '''
    poly1_end = Polygon(
        vertices=(Pt(-0.2, -2.5), Pt(0.2, -2.5), Pt(0.2, 0.2), Pt(-0.2, 0.2)),
        weight=1.0,
        name="web",
    )
    '''
    # --------------------------------------------------------
    # 3. CREATE SECTIONS WITH Z-COORDINATES
    # --------------------------------------------------------
    # Each Section groups polygons and assigns a Z position.

    s0 = Section(polygons=(poly0_start, poly1_start), z=0.0)
    s1 = Section(polygons=(poly0_end, poly1_end), z=10.0)

    # --------------------------------------------------------
    # 4. INITIALIZE CONTINUOUS SECTION FIELD
    # --------------------------------------------------------
    # A linear interpolator is used to generate intermediate
    # sections between Z = 0 and Z = 10.
    field = ContinuousSectionField(section0=s0, section1=s1)


    # --------------------------------------------------------
    # 5. PRIMARY SECTION PROPERTIES (Z = 5.0)
    # --------------------------------------------------------
    # Properties are computed at mid-span.
    sec_mid = field.section(5.0)
    props = section_properties(sec_mid)


    # ============================================================
    # COMPLETE MODEL CAPABILITIES VERIFICATION (18 POINTS)
    # ============================================================
    print("\n" + "="*60)
    print("FULL MODEL ANALYSIS REPORT - SECTION AT Z=5.0")
    print("="*60)

    # Run the full analysis using Saint-Venant theory
    full_analysis = section_full_analysis(sec_mid)
    
    # 1-7) Proprietà Primarie
    print(f"1) Area (A):               {full_analysis['A']:.4f}      # Net area")
    print(f"2) Centroid Cx:            {full_analysis['Cx']:.4f}     # Horizontal CG")
    print(f"3) Centroid Cy:            {full_analysis['Cy']:.4f}     # Vertical CG")
    print(f"4) Inertia Ix:             {full_analysis['Ix']:.4f}     # Centroidal X Inertia")
    print(f"5) Inertia Iy:             {full_analysis['Iy']:.4f}     # Centroidal Y Inertia")
    print(f"6) Inertia Ixy:            {full_analysis['Ixy']:.4f}    # Product of Inertia")
    print(f"7) Polar Moment (J):       {full_analysis['J']:.4f}      # Ix + Iy")

    # 8-11) Derived Properties and Principal Axes
    print(f"8) Principal Inertia I1:   {full_analysis['I1']:.4f}     # Max Principal Moment")
    print(f"9) Principal Inertia I2:   {full_analysis['I2']:.4f}     # Min Principal Moment")
    print(f"10) Radius of Gyration rx: {full_analysis['rx']:.4f}     # sqrt(Ix/A)")
    print(f"11) Radius of Gyration ry: {full_analysis['ry']:.4f}     # sqrt(Iy/A)")

    # 12-14) Strength and Torsional Properties
    print(f"12) Elastic Modulus Wx:    {full_analysis['Wx']:.4f}     # Ix / y_max")
    print(f"13) Elastic Modulus Wy:    {full_analysis['Wy']:.4f}     # Iy / x_max")
    print(f"14) Torsional Rigidity K:  {full_analysis['K_torsion']:.4f} # Saint-Venant K")

    # 15-16) Direct checks on individual polygons (Polygon 0: Flange)
    poly0 = sec_mid.polygons[0]
    ix_orig, _, _ = polygon_inertia_about_origin(poly0)
    q_poly0 = polygon_statical_moment(poly0, y_axis=full_analysis['Cy'])

    print(f"15) Polygon 0 Ix (Origin): {ix_orig:.4f}     # Direct call verification")
    print(f"16) Polygon 0 Q_local:     {q_poly0:.4f}     # Direct call verification")

    # 17) Static moment for shear (partial section)
    q_na = section_statical_moment_partial(sec_mid, y_cut=full_analysis['Cy'])
    print(f"17) Section Q_na:          {q_na:.4f}     # Statical moment for shear (at Neutral Axis)")

    # 18) Stiffness matrix (constitutive analysis)
    k_matrix = section_stiffness_matrix(sec_mid, E_ref=210000) # Esempio Acciaio
    print(f"18) Stiffness Matrix Shape: {k_matrix.shape}       # Direct call verification (3x3 Matrix)")
    
    print("="*60)
    # --------------------------------------------------------
    # 9. VISUALIZATION
    # --------------------------------------------------------
    # - 2D section plot at Z = 5.0
    # - 3D ruled solid visualization
    viz = Visualizer(field)
    # Generate 2D plot for the specified slice
    viz.plot_section_2d(z=5.0)
    # Generate 3D plot of the interpolated solid
    # line_percent determines the density of the longitudinal ruled lines
    viz.plot_volume_3d(line_percent=100.0, seed=1)
    import matplotlib.pyplot as plt
    plt.show()

